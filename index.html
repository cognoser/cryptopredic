<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Top Cryptos Bites and News and Predictor based on Candle stick pattern analysis</title>
  <link rel="icon" href="/favicon.ico" type="image/x-icon">
  <meta name="description" content="Daily crypto bites, Top crypto news, Crypto headlines, Live crypto prices, Candlestick charts and Predictor based on candle sticks analyse."/>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .news-card img { width: 120px; height: 80px; object-fit: cover; border-radius: 6px; }
    .truncate-2 { 
      display: -webkit-box; 
      -webkit-line-clamp: 2; 
      -webkit-box-orient: vertical; 
      overflow: hidden; 
      line-clamp: 2; 
      box-orient: vertical;
    }
    #daily-update { max-height: 360px; overflow:auto; }
  </style>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-93VYTJML1K"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-93VYTJML1K');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9978786369623839"
     crossorigin="anonymous"></script>
</head>
<body class="bg-gray-900 text-gray-100 min-h-screen">


  <div class="max-w-7xl mx-auto p-4">
    <header class="flex items-center justify-between mb-4">
      <div>
        <h1 class="text-2xl font-bold">TopCryptosNews</h1>
      </div>
	<div class="flex items-center gap-4">
      <div class="text-right text-sm text-gray-400">
        <div id="last-updated">â€”</div>
	<img src="tcn.jpg" alt="TopCryptoNews" class="w-1000 h-10 object-contain" />
  </div>
      </div>
    </header>


    <main class="space-y-4">
  <!-- Row 1: Today's Crypto Bites -->
  <section class="grid grid-cols-1 gap-4">
    <div class="bg-gray-800 p-4 rounded-2xl shadow">
      <h2 class="text-lg font-semibold mb-2">Today's Crypto BitesðŸš¨</h2>
      <div id="daily-update" class="prose prose-invert text-sm leading-loose"">


<b>Headlines:</b><br>
-> <b>Historic $19B Crypto Liquidation Shakes Markets:</b> The largest single-day wipeout in crypto history hit on October 10, erasing $19 billion in leveraged positions amid Trump's surprise 100% tariffs on Chinese goods, with Bitcoin plunging from $122,500 to $104,600.<br>
-> <b>Bitcoin Recovers to $105K Amid Ongoing Volatility:</b> After dipping below $110K in the weekend rout, BTC bounces 4.64% to $105,774 as analysts eye Fed rate cuts and ETF inflows for stabilization, though resistance at $114K looms large.<br>
-> <b>US Passes Landmark CLARITY Act for Crypto:</b> House approves Digital Asset Market CLARITY Act 294-134, clarifying SEC-CFTC roles on tokens as securities vs. commodities, boosting institutional confidence despite Senate hurdles.<br>
-> <b>Ethereum Surges 5.89% to $3,787 on ETF Optimism:</b> ETH leads altcoin rebound with spot ETF inflows hitting $236M last week, as MiCA rules in Europe pave way for broader adoption, analysts forecast $4,500 breakout soon.

<br><br>
<b>Market Overview:</b><br>
As of October 18, 2025, the crypto market cap stands at $3.58 trillion, down 4.96% in the last 24 hours following the brutal October liquidation frenzy that wiped out billions. Bitcoin trades at $105,774, up 4.64% today but still reeling from its drop below $105K last week, while Ethereum climbs 5.89% to $3,787 amid renewed ETF enthusiasm. Altcoins show mixed vibesâ€”gainers like AVAX (+10.11%) and TAO (+10.30%) signal AI and layer-1 strength, but many lag behind BTC's dominance, now at 58.98% after spiking during the crash. 24-hour volume exploded 40.97% to $276.25 billion, driven by DeFi ($26B) and stablecoins ($269.84B), hinting at hedging flows. Big money inflows into US BTC/ETH ETFs totaled over $338M this week despite outflows earlier, while corporate BTC treasuries hit $117 billion. Broader economy news, including Trump's tariff escalations and Fed's dovish hints on October rate cuts, keeps volatility high, but on-chain metrics like positive funding rates suggest a potential bottom forming for a Q4 rally.

<br><br>
<b>Market Sentiment:</b><br>
The mood in crypto is gripped by extreme fear today, with the Fear & Greed Index plummeting to 26 from 64 just days ago, signaling capitulation after the $19B liquidation bloodbath. BTC dominance at 58.98% underscores flight to safety, squeezing altcoins as traders hammer longs amid US-China trade jitters. Key supports hold at BTC's $104K low, with resistance at $114K-$117K; analysts like Bitwise's Matt Hougan call this a "technical reset" cleaning leverage, eyeing Fed QE and ETF approvals as bullish catalysts. X chatter echoes bearish panicâ€”"bloodbath" and "crypto winter" dominate, but contrarians spot oversold RSI at 28 as a buy signal, with whales accumulating shorts for a squeeze. Volatility warnings abound: leverage amplified the crash 19x past events, per CoinGlass, urging de-risking as retail FOMO fades. Still, 78% bullish retail sentiment on futures hints at hidden strengthâ€”stay nimble, bottoms often feel like ends.

<br><br>
<b>Regulatory Roundup:</b><br>
Hey folks, October's been a whirlwind for crypto regsâ€”finally some light after years of fog. In the US, the House just rammed through the CLARITY Act with a whopping 294-134 vote, drawing a clear line between SEC's security tokens and CFTC's commodities, which could supercharge institutional plays but watch for Senate drama holding up full passage by year-end. Trump's crypto-friendly pivot dissolved the old SEC enforcement squad for a fresh Task Force, easing ETF listings and eyeing stablecoin rules that might just spark that "fintech revolution" he hyped. Over in Europe, MiCA's rolling out stablecoin oversight, giving Bank of France direct reins on firmsâ€”great for adoption, less fraud, but brace for compliance headaches on tokenized stocks racing ahead. Globally, PwC notes Trump's shift from Biden's enforcement hammer, with IOSCO pushing 18 recs for service providers. It's all boosting clarity and inflows, yet risks like fragmented liquidity and investor protections lingerâ€”smart money's adapting, but don't sleep on enforcement surprises.


<br><br>
Check charts powered by Trading view for quick glance. Also do not forget to try the predictor/analyzer tool ðŸ“Š which analyze candle stick pattern to predict price movementðŸš¦

          </div>
        </div>
 </section>

 <section class="grid grid-cols-1 lg:grid-cols-5 gap-4">
        <div class="lg:col-span-3 bg-gray-800 p-4 rounded-2xl shadow flex flex-col">
          <!-- Responsive chart header -->
          <div class="flex flex-col sm:flex-col sm:items-center sm:justify-between gap-3 mb-3">
            <div class="flex flex-col sm:flex-row gap-3 sm:items-end w-full">
              <div>
                
                <input id="symbolInput" class="bg-gray-900 text-white px-3 py-2 rounded w-full sm:w-36" placeholder="BTCUSDT" />
              </div>
              <div class="flex flex-col">
                
                <div class="flex gap-2 flex-wrap items-center">
                  <button class="quick-btn px-2 py-1 sm:px-3 sm:py-2 bg-gray-700 rounded text-sm" data-symbol="BTCUSDT">BTC</button>
                  <button class="quick-btn px-2 py-1 sm:px-3 sm:py-2 bg-gray-700 rounded text-sm" data-symbol="ETHUSDT">ETH</button>
                  <button class="quick-btn px-2 py-1 sm:px-3 sm:py-2 bg-gray-700 rounded text-sm" data-symbol="XRPUSDT">XRP</button>
		  <button class="quick-btn px-2 py-1 sm:px-3 sm:py-2 bg-gray-700 rounded text-sm" data-symbol="BNBUSDT">BNB</button>
		  <!--button class="quick-btn px-2 py-1 sm:px-3 sm:py-2 bg-gray-700 rounded text-sm" data-symbol="SOLUSDT">SOL</button-->
		  <!--button class="quick-btn px-2 py-1 sm:px-3 sm:py-2 bg-gray-700 rounded text-sm" data-symbol="DOGEUSDT">DOGE</button-->
		  		  
                  <div class="ml-4 flex flex-col text-left sm:text-right">
                    <div class="text-xs text-gray-400">Live price</div>
                    <div id="price" class="text-lg sm:text-xl font-semibold">â€”</div>
                    <div id="change" class="text-xs sm:text-sm text-gray-400">â€”</div>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <div id="tradingview-widget" class="rounded flex-grow" style="background:#0f1724; padding:6px;"></div>
        </div>

        <div class="lg:col-span-2 bg-gray-800 p-4 rounded-2xl shadow flex flex-col">
          <h2 class="text-lg font-semibold mb-3">Predictor</h2>
          <div class="mb-3">
            <label for="predictorSymbol" class="block text-xs text-gray-400 mb-1">Symbol</label>
            <input id="predictorSymbol" class="bg-gray-900 text-white px-3 py-2 rounded w-full" placeholder="BTCUSDT" />
          </div>
          <div class="mb-3">
            <label for="predictorQuick" class="block text-xs text-gray-400 mb-1">Quick Picks</label>
            <div class="flex gap-2 flex-wrap">
              <button class="predictor-quick-btn px-2 py-1 sm:px-3 sm:py-2 bg-gray-700 rounded text-sm" data-symbol="BTCUSDT">BTC</button>
              <button class="predictor-quick-btn px-2 py-1 sm:px-3 sm:py-2 bg-gray-700 rounded text-sm" data-symbol="ETHUSDT">ETH</button>
              <button class="predictor-quick-btn px-2 py-1 sm:px-3 sm:py-2 bg-gray-700 rounded text-sm" data-symbol="BNBUSDT">BNB</button>
              <button class="predictor-quick-btn px-2 py-1 sm:px-3 sm:py-2 bg-gray-700 rounded text-sm" data-symbol="SOLUSDT">SOL</button>
            </div>
          </div>
          <div class="mb-3">
            <label for="intervalSelect" class="block text-xs text-gray-400 mb-1">Interval</label>
            <select id="intervalSelect" class="bg-gray-900 text-white px-3 py-2 rounded w-full">
              <option value="1m">1 Minute</option>
              <option value="3m">3 Minutes</option>
              <option value="5m" selected>5 Minutes</option>
              <option value="15m">15 Minutes</option>
              <option value="30m">30 Minutes</option>
              <option value="1h">1 Hour</option>
              <option value="2h">2 Hours</option>
              <option value="4h">4 Hours</option>
              <option value="6h">6 Hours</option>
              <option value="8h">8 Hours</option>
              <option value="12h">12 Hours</option>
              <option value="1d">1 Day</option>
              <option value="3d">3 Days</option>
              <option value="1w">1 Week</option>
              <option value="1M">1 Month</option>
            </select>
          </div>
          <div class="mb-4">
            <label for="candleCountSelect" class="block text-xs text-gray-400 mb-1">Candles to Analyze</label>
            <select id="candleCountSelect" class="bg-gray-900 text-white px-3 py-2 rounded w-full">
              <option value="5">5</option>
              <option value="10" selected>10</option>
              <option value="15">15</option>
              <option value="20">20</option>
              <option value="25">25</option>
              <option value="30">30</option>
              <option value="40">40</option>
              <option value="50">50</option>
            </select>
          </div>
          <button id="analyzeBtn" class="bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded text-white font-semibold mb-3">Analyze</button>
          <div id="predictionResult" class="flex-grow overflow-auto text-sm prose prose-invert"></div>

          <section id="candleDiagramSection" class="mt-auto">
            <svg id="candleDiagram" width="0%" height="0" viewBox="0 0 0 0"></svg>
            <p class="text-gray-400 text-xs italic mt-2">
              Note: This tool works by analysing candle stick patterns and it may not always produce correct result. Do not take decisions based on this.
            </p>
          </section>
        </div>
      </section>

      <section class="bg-gray-800 p-4 rounded-2xl shadow">
        <h2 class="text-lg font-semibold mb-2">Latest Crypto News</h2>
        <div id="newsList" class="grid grid-cols-1 md:grid-cols-2 gap-3 max-h-96 overflow-auto">
          <p class="text-gray-400 text-sm col-span-full">Loading newsâ€¦</p>
        </div>
        <div class="mt-3 text-xs text-gray-500">Sources: CoinDesk, Bitcoin, CoinTelegraph</div>
      </section>
    </main>

    <footer style="background:#111; color:#bbb; text-align:center; padding:20px; font-size:14px; margin-top:30px;">
  <p>
    Market data provided by 
    <a href="https://www.binance.com" target="_blank" style="color:#4da6ff;">Binance API</a>.  
    Charts powered by 
    <a href="https://www.tradingview.com/" target="_blank" style="color:#4da6ff;">TradingView</a>.  
    News aggregated from 
    <a href="https://www.coingecko.com/en/news" target="_blank" style="color:#4da6ff;">CoinGecko</a>, 
    <a href="https://news.bitcoin.com/" target="_blank" style="color:#4da6ff;">Bitcoin.com</a>, and 
    <a href="https://www.coindesk.com/" target="_blank" style="color:#4da6ff;">CoinDesk</a>.
  </p>
   <p>
    <a href="privacypolicy.html">Privacy Policy</a> | 
    <a href="terms.html">Terms of Use</a> | 
    <a href="contact.html">Contact</a>
  </p>
    
  <p>Â© 2025 <a href="https://topcryptosnews.com" style="color:#0f9dff; text-decoration:none;">topcryptosnews.com</a>. All rights reserved.</p>
</footer>
  </div>

<script>
  const DEFAULT_SYMBOL = 'BTCUSDT';
  const BINANCE_REST_PRICE = (sym) => `https://api.binance.com/api/v3/ticker/24hr?symbol=${encodeURIComponent(sym)}`;
  const BINANCE_KLINES = (sym, interval, limit) => `https://api.binance.com/api/v3/klines?symbol=${encodeURIComponent(sym)}&interval=${interval}&limit=${limit}`;

  function $qs(s) { return document.querySelector(s); }

  async function fetchPrice(sym) {
    try {
      const res = await fetch(BINANCE_REST_PRICE(sym));
      if (!res.ok) throw new Error('Price fetch failed');
      const data = await res.json();
      $qs('#price').textContent = parseFloat(data.lastPrice).toLocaleString();
      const ch = parseFloat(data.priceChangePercent);
      const chEl = $qs('#change');
      chEl.textContent = (ch>=0?'+':'') + ch.toFixed(2) + '%  Â·  vol: ' + Number(data.volume).toFixed(0);
      chEl.style.color = ch>=0 ? '#34d399' : '#fb7185';
      $qs('#last-updated').textContent = '';
    } catch(err) {
      console.error(err);
      $qs('#price').textContent = 'â€”';
      $qs('#change').textContent = 'Price unavailable';
    }
  }

  function createTradingViewWidget(sym) {
    const symbolForTV = 'BINANCE:' + sym.replace(/USDT$/,'USDT');
    const container = $qs('#tradingview-widget');
    container.innerHTML = '';
    const widget = document.createElement('div');
    widget.id = 'tv-lightweight';
    container.appendChild(widget);

    const existingScript = document.querySelector('script[src="https://s3.tradingview.com/tv.js"]');
    if (existingScript) existingScript.remove();

    const script = document.createElement('script');
    script.type = 'text/javascript';
    script.src = 'https://s3.tradingview.com/tv.js';
    script.onload = () => {
      try {
        new TradingView.widget({
          "width": "100%",
          "height": 420,
          "symbol": symbolForTV,
          "interval": "60",
          "timezone": "Etc/UTC",
          "theme": "dark",
          "style": "1",
          "locale": "en",
          "toolbar_bg": "#f1f3f6",
          "enable_publishing": false,
          "allow_symbol_change": true,
          "container_id": "tv-lightweight"
        });
      } catch(e) {
        console.error('TV widget error', e);
        container.innerHTML = '<div class="p-6 text-center text-sm text-red-400">Chart failed to load.</div>';
      }
    };
    document.body.appendChild(script);
  }

  let allNewsItems = [];
  let currentIndex = 0;
  const pageSize = 8; // how many news items per scroll
  let isLoading = false;
  async function fetchNews() {
  const cacheKey = 'topcryptosnews_news_cache';
  const cacheExpiryKey = 'topcryptosnews_news_cache_expiry';
  const now = Date.now();
  const cacheExpiry = localStorage.getItem(cacheExpiryKey);
  const cached = localStorage.getItem(cacheKey);

  if (cached && cacheExpiry && now < parseInt(cacheExpiry,10)) {
    renderNews(JSON.parse(cached));
    return;
  }

  const feeds = [
    'https://www.coindesk.com/arc/outboundfeeds/rss/',
    'https://news.bitcoin.com/feed/',
    'https://cointelegraph.com/rss'
       // âœ… Added Bitcoin.com RSS
  ];

  const items = [];
  for (const feed of feeds) {
    try {
      const proxy = 'https://api.allorigins.win/raw?url=' + encodeURIComponent(feed);
      const resp = await fetch(proxy);
      if (!resp.ok) continue;
      const txt = await resp.text();
      const parser = new DOMParser();
      const xml = parser.parseFromString(txt, 'application/xml');
      const xmlItems = Array.from(xml.querySelectorAll('item')).slice(0,6);
      for (const it of xmlItems) {
        const title = it.querySelector('title') ? it.querySelector('title').textContent : 'No title';
        const link = it.querySelector('link') ? it.querySelector('link').textContent : '#';
        const desc = it.querySelector('description') ? it.querySelector('description').textContent : '';
        let img = null;
        const media = it.getElementsByTagName('media:content');
        if (media && media.length) img = media[0].getAttribute('url');
        if (!img) {
          const enc = it.querySelector('enclosure[url]');
          if (enc) img = enc.getAttribute('url');
        }
        if (!img) {
          const m = desc.match(/<img[^>]+src="([^">]+)"/i);
          if (m) img = m[1];
        }
        items.push({title, link, desc, img, source: new URL(feed).hostname});
      }
    } catch(e) {
      console.warn('feed failed', feed, e);
    }
  }

  localStorage.setItem(cacheKey, JSON.stringify(items));
  localStorage.setItem(cacheExpiryKey, (now + 600000).toString());

  allNewsItems = items;
  renderNews(allNewsItems);
  }

  function renderNews(items, append = false) {
  const list = $qs('#newsList');
  if (!append) {
    list.innerHTML = '';
    currentIndex = 0;
  }

  const slice = items.slice(currentIndex, currentIndex + pageSize);
  slice.forEach(it => {
    const card = document.createElement('a');
    card.className = 'news-card block bg-gray-900 p-3 rounded hover:shadow-md flex gap-3';
    card.href = it.link;
    card.target = '_blank';
    card.rel = 'noopener noreferrer';
    card.innerHTML = `
      <div class="flex-1">
        <div class="text-sm font-semibold mb-1">${escapeHtml(it.title)}</div>
        <div class="text-gray-400 text-xs truncate-2">${escapeHtml(stripHtml(it.desc)).slice(0,220)}</div>
        <div class="text-xs text-gray-500 mt-2">${it.source}</div>
      </div>
      ${it.img ? `<div class="hidden sm:block"><img src="${it.img}" alt="" /></div>` : ''}
    `;
    list.appendChild(card);
  });

  currentIndex += slice.length;
  isLoading = false;
}

  function stripHtml(htmlStr) {
    const tmp = document.createElement('div');
    tmp.innerHTML = htmlStr;
    return tmp.textContent || tmp.innerText || '';
  }

  // Utility functions for candle calculations
  function candleBody(candle) {
    return Math.abs(candle.close - candle.open);
  }
  function candleRange(candle) {
    return candle.high - candle.low;
  }
  function isBullish(candle) {
    return candle.close > candle.open;
  }
  function isBearish(candle) {
    return candle.open > candle.close;
  }
  function isDoji(candle, threshold = 0.1) {
    const body = candleBody(candle);
    const range = candleRange(candle);
    return body <= range * threshold;
  }

  // Pattern detection functions for popular patterns
  function detectBullishEngulfing(prev, curr) {
    return isBearish(prev) && isBullish(curr) && curr.open < prev.close && curr.close > prev.open;
  }
  function detectBearishEngulfing(prev, curr) {
    return isBullish(prev) && isBearish(curr) && curr.open > prev.close && curr.close < prev.open;
  }
  function detectHammer(candle) {
    const body = candleBody(candle);
    const range = candleRange(candle);
    const lowerShadow = candle.open > candle.close ? candle.close - candle.low : candle.open - candle.low;
    const upperShadow = candle.high - Math.max(candle.open, candle.close);
    return lowerShadow > 2 * body && upperShadow < body && body / range < 0.3;
  }
  function detectHangingMan(candle) {
    // Similar to Hammer but appears after uptrend - simplified here just check hammer shape
    return detectHammer(candle);
  }
  function detectShootingStar(candle) {
    const body = candleBody(candle);
    const range = candleRange(candle);
    const upperShadow = candle.high - Math.max(candle.open, candle.close);
    const lowerShadow = Math.min(candle.open, candle.close) - candle.low;
    return upperShadow > 2 * body && lowerShadow < body && body / range < 0.3;
  }
  function detectDoji(candle) {
    return isDoji(candle);
  }
  function detectPiercingLine(prev, curr) {
    return isBearish(prev) && isBullish(curr) && curr.open < prev.low && curr.close > (prev.open + prev.close) / 2;
  }
  function detectDarkCloudCover(prev, curr) {
    return isBullish(prev) && isBearish(curr) && curr.open > prev.high && curr.close < (prev.open + prev.close) / 2;
  }
  function detectMorningStar(prev2, prev1, curr) {
    return (
      isBearish(prev2) &&
      isDoji(prev1) &&
      isBullish(curr) &&
      curr.close > (prev2.open + prev2.close) / 2
    );
  }
  function detectEveningStar(prev2, prev1, curr) {
    return (
      isBullish(prev2) &&
      isDoji(prev1) &&
      isBearish(curr) &&
      curr.close < (prev2.open + prev2.close) / 2
    );
  }

  // Sentiment mapping for patterns
  const PATTERNS = [
    { name: 'Bullish Engulfing', detect: detectBullishEngulfing, sentiment: 'Bullish', description: 'A bullish reversal pattern where a small bearish candle is followed by a large bullish candle that completely engulfs the previous candle.' },
    { name: 'Bearish Engulfing', detect: detectBearishEngulfing, sentiment: 'Bearish', description: 'A bearish reversal pattern where a small bullish candle is followed by a large bearish candle that completely engulfs the previous candle.' },
    { name: 'Hammer', detect: detectHammer, sentiment: 'Bullish', description: 'A bullish reversal pattern characterized by a small body and a long lower shadow, showing that buyers pushed prices up after a sell-off.' },
    { name: 'Hanging Man', detect: detectHangingMan, sentiment: 'Bearish', description: 'A bearish reversal pattern that looks like a hammer but appears after an uptrend, warning of a potential reversal.' },
    { name: 'Shooting Star', detect: detectShootingStar, sentiment: 'Bearish', description: 'A bearish reversal pattern with a small body and long upper shadow, indicating selling pressure after a rally.' },
    { name: 'Doji', detect: detectDoji, sentiment: 'Neutral', description: 'A neutral pattern where open and close prices are very close, signaling indecision in the market.' },
    { name: 'Piercing Line', detect: detectPiercingLine, sentiment: 'Bullish', description: 'A bullish reversal pattern where a bearish candle is followed by a bullish candle that opens lower but closes above the midpoint of the previous candle.' },
    { name: 'Dark Cloud Cover', detect: detectDarkCloudCover, sentiment: 'Bearish', description: 'A bearish reversal pattern where a bullish candle is followed by a bearish candle that opens higher but closes below the midpoint of the previous candle.' },
    { name: 'Morning Star', detect: detectMorningStar, sentiment: 'Bullish', description: 'A bullish reversal pattern consisting of a bearish candle, a doji or small candle, and a bullish candle.' },
    { name: 'Evening Star', detect: detectEveningStar, sentiment: 'Bearish', description: 'A bearish reversal pattern consisting of a bullish candle, a doji or small candle, and a bearish candle.' },
  ];

  function analyzePatterns(klines) {
    // klines: array of [openTime, open, high, low, close, volume, ...]
    // We'll convert into candle objects with floats
    const candles = klines.map(k => ({
      open: parseFloat(k[1]),
      high: parseFloat(k[2]),
      low: parseFloat(k[3]),
      close: parseFloat(k[4]),
      volume: parseFloat(k[5]),
    }));

    const detectedPatterns = [];

    // For patterns needing 3 candles: Morning Star, Evening Star
    for(let i=2; i < candles.length; i++) {
      const c2 = candles[i-2];
      const c1 = candles[i-1];
      const c0 = candles[i];

      PATTERNS.forEach(p => {
        if(p.name === 'Morning Star' || p.name === 'Evening Star') {
          if(p.detect(c2,c1,c0)) {
            detectedPatterns.push({ ...p, index: i-2 });
          }
        }
      });
    }

    // For 2-candle patterns: Bullish Engulfing, Bearish Engulfing, Piercing Line, Dark Cloud Cover
    for(let i=1; i < candles.length; i++) {
      const prev = candles[i-1];
      const curr = candles[i];
      PATTERNS.forEach(p => {
        if(['Bullish Engulfing','Bearish Engulfing','Piercing Line','Dark Cloud Cover'].includes(p.name)) {
          if(p.detect(prev, curr)) {
            detectedPatterns.push({ ...p, index: i-1 });
          }
        }
      });
    }

    // For single candle patterns: Hammer, Hanging Man, Shooting Star, Doji
    candles.forEach((c, i) => {
      PATTERNS.forEach(p => {
        if(['Hammer','Hanging Man','Shooting Star','Doji'].includes(p.name)) {
          if(p.detect(c)) {
            detectedPatterns.push({ ...p, index: i });
          }
        }
      });
    });

    // Aggregate sentiment scores for prediction
    // Assign scores to sentiments:
    // Bullish = +2, Slightly Bullish = +1 (we don't have that here, but could add)
    // Neutral = 0
    // Bearish = -2, Slightly Bearish = -1
    // We'll sum and get average to decide overall sentiment

    let score = 0;
    let counts = { Bullish: 0, Bearish: 0, Neutral: 0 };
    detectedPatterns.forEach(p => {
      if(p.sentiment === 'Bullish') { score += 2; counts.Bullish++; }
      else if(p.sentiment === 'Bearish') { score -= 2; counts.Bearish++; }
      else counts.Neutral++;
    });

    let overallSentiment = 'Neutral';
    if(score >= 3) overallSentiment = 'Bullish';
    else if(score > 0) overallSentiment = 'Slightly Bullish';
    else if(score <= -3) overallSentiment = 'Bearish';
    else if(score < 0) overallSentiment = 'Slightly Bearish';

    // Explanation based on best detected pattern (first detected by index ascending)
    detectedPatterns.sort((a,b) => a.index - b.index);
    let explanation = '';
    if(detectedPatterns.length === 0) {
      explanation = 'No clear candlestick pattern detected in the analyzed candles.';
    } else {
      const top = detectedPatterns[0];
      explanation = `Based on the last analyzed candles, the pattern <strong>${top.name}</strong> was detected, which is considered <strong>${top.sentiment}</strong>. This pattern typically suggests that the price may ${top.sentiment === 'Bullish' ? 'rise' : (top.sentiment === 'Bearish' ? 'fall' : 'move sideways')}.`;
    }

    return {
      patterns: detectedPatterns,
      overallSentiment,
      explanation,
    };
  }

  async function analyzePrediction(symbol, interval, candleCount) {
    const url = BINANCE_KLINES(symbol, interval, candleCount);
    const resp = await fetch(url);
    if (!resp.ok) throw new Error('Fetch failed');
    const data = await resp.json();
    return analyzePatterns(data);
  }

  function showPrediction(result) {
  const container = $qs('#predictionResult');
  container.innerHTML = '';
  if (!result) {
    container.innerHTML = `<p class="text-gray-400">No data to analyze.</p>`;
    return;
  }

  if (!result.patterns.length) {
    container.innerHTML = `<p class="text-gray-400">No clear candlestick pattern found on analyzed candles.</p><p>${result.explanation}</p>`;
    return;
  }

  const sentimentColors = {
    'Bullish': 'green',
    'Bearish': 'red',
    'Neutral': 'yellow',
    'Slightly Bullish': 'lime',
    'Slightly Bearish': 'orange'
  };

  const overallColor = sentimentColors[result.overallSentiment] || 'gray';

  // All detected patterns in collapsible details
  const allPatternsHTML = result.patterns.map(p => 
    `<details class="mb-2 bg-gray-700 rounded p-2">
      <summary class="font-semibold cursor-pointer">${p.name} - <span class="text-${sentimentColors[p.sentiment] || 'gray'}-400">${p.sentiment}</span></summary>
      <p class="mt-1 text-xs text-gray-300">${p.description}</p>
    </details>`).join('');

  container.innerHTML = `
    <p><strong>Overall Prediction:</strong> <span class="text-${overallColor}-400">${result.overallSentiment}</span></p>
    <p class="mb-2 text-xs text-gray-400"><em>${result.explanation}</em></p>
    <hr class="border-gray-600 mb-2"/>
    <details class="bg-gray-800 rounded p-2">
      <summary class="cursor-pointer font-semibold text-sm mb-2">ðŸ“Š Show/Hide Detected Patterns</summary>
      <div class="mt-2">
        ${allPatternsHTML}
      </div>
    </details>
  `;
}

  // Candle diagram rendering function
  function renderCandleDiagram(count) {
    const svg = document.getElementById('candleDiagram');
    svg.innerHTML = '';

    const width = 1000;
    const height = 70;
    const candleWidth = Math.min(80, width / count - 4);
    const spacing = 4;
    const totalWidth = count * (candleWidth + spacing);

    svg.setAttribute('viewBox', `0 0 ${totalWidth} ${height}`);

    // Timeline line
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('x1', '0');
    line.setAttribute('y1', '50');
    line.setAttribute('x2', totalWidth);
    line.setAttribute('y2', '50');
    line.setAttribute('stroke', '#4b5563');
    line.setAttribute('stroke-width', '3');
    svg.appendChild(line);

    for(let i = 0; i < count; i++) {
      const x = i * (candleWidth + spacing);
      const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      rect.setAttribute('x', x);
      rect.setAttribute('y', 20);
      rect.setAttribute('width', candleWidth);
      rect.setAttribute('height', 40);
      rect.setAttribute('fill', i === count - 1 ? '#34d399' : '#2563eb');
      svg.appendChild(rect);

      const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      text.setAttribute('x', x + candleWidth / 2);
      text.setAttribute('y', 65);
      text.setAttribute('fill', i === count - 1 ? '#34d399' : '#9ca3af');
      text.setAttribute('font-weight', i === count - 1 ? 'bold' : 'normal');
      text.setAttribute('font-family', 'monospace');
      text.setAttribute('font-size', '12');
      text.setAttribute('text-anchor', 'middle');
      text.textContent = `#${count - i}${i === count - 1 ? ' (Latest)' : ''}`;
      svg.appendChild(text);
    }
  }

  // Escape HTML utility for safety
  function escapeHtml(str) {
    return String(str)
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;');
  }

  // --- Event handlers & startup ---
  document.addEventListener('DOMContentLoaded', () => {

    window.addEventListener('scroll', () => {
  if (isLoading) return;

  if (window.innerHeight + window.scrollY >= document.body.offsetHeight - 200) {
    if (currentIndex < allNewsItems.length) {
      isLoading = true;
      renderNews(allNewsItems, true);
    }
  }
});
    const symbolInput = $qs('#symbolInput');
    const priceEl = $qs('#price');
    const changeEl = $qs('#change');
    const lastUpdatedEl = $qs('#last-updated');
    const quickBtns = document.querySelectorAll('.quick-btn');

    // Predictor inputs
    const predictorSymbol = $qs('#predictorSymbol');
    const predictorQuickBtns = document.querySelectorAll('.predictor-quick-btn');
    const intervalSelect = $qs('#intervalSelect');
    const analyzeBtn = $qs('#analyzeBtn');
    const candleCountSelect = $qs('#candleCountSelect');

    // Setup quick buttons for chart symbol
    quickBtns.forEach(btn => {
      btn.addEventListener('click', () => {
        const sym = btn.dataset.symbol;
        symbolInput.value = sym;
        updateChart(sym);
      });
    });

    // Setup quick buttons for predictor
    predictorQuickBtns.forEach(btn => {
      btn.addEventListener('click', () => {
        predictorSymbol.value = btn.dataset.symbol;
      });
    });

    // On analyze button click
    analyzeBtn.addEventListener('click', async () => {
      const sym = predictorSymbol.value.trim().toUpperCase() || DEFAULT_SYMBOL;
      const interval = intervalSelect.value;
      const candleCount = parseInt(candleCountSelect.value, 10) || 10;
      $qs('#predictionResult').innerHTML = '<p>Analyzing pattern...</p>';
      try {
        const result = await analyzePrediction(sym, interval, candleCount);
        showPrediction(result);
      } catch (e) {
        $qs('#predictionResult').innerHTML = `<p class="text-red-500">Error fetching or analyzing pattern data.</p>`;
      }
    });

    // Candle count change updates candle diagram
    candleCountSelect.addEventListener('change', (e) => {
      const val = parseInt(e.target.value, 10);
      renderCandleDiagram(val);
    });

    // Initial render candle diagram with default 10
    renderCandleDiagram(parseInt(candleCountSelect.value, 10));

    // Initial chart and price load
    function updateChart(sym) {
      if (!sym) return;
      createTradingViewWidget(sym);
      fetchPrice(sym);
    }
    symbolInput.value = DEFAULT_SYMBOL;
    predictorSymbol.value = DEFAULT_SYMBOL;
    updateChart(DEFAULT_SYMBOL);
    fetchNews();
  });
  </script>

</body>
</html>
